---//$Id$//

====== Interrupts manager overview ======

Interrupts manager functionality is implemented in ''IM'' class. Only one instance of this class is present in the system (''im'' global variable). Main function of the IM is to service interrupts requests with different priority levels from different hardware and software sources. The IM has limited number of slots for each interrupt type (currently 16 for hardware and 32 for software interrupts). Each slot can have unlimited number of clients which could process the interrupt on this slot. Each client has its own priority value. When client is servicing an interrupt request, all interrupts with the same and lower priority are masked. However, interrupts requests still can be accepted but they might not be serviced immediately - if the request is masked it will get 'pending' status and will be serviced when the IRQ line (slot) is unmasked. Order of pending interrupts servicing is determined by scheduler algorithm which accounts priorities and gives a chance to every slot be serviced using round-robin balancing. IM provides interface to the system for interrupts requests posting, masking and unmasking specific interrupts, setting current interrupts priority level, disabling and enabling hardware interrupts, dynamical IRQ slots allocation and clients registration. 
Interrupts and exceptions handling

Low level interrupts and exception entry point code located in ''kernel/kern/trap.S'' file. Main specific feature of this code is dynamically installed entries in the interrupts vectors table. Each entry contains small piece of code (from ''TrapEntry'' to ''TrapEntryEnd'') which is copied in all slots of the vectors table (this done by ''IDT'' class constructor). The code stores in the stack %eax register value, return address and jumps to ''TrapHandler'' common code. ''TrapHandler'' uses stored address to determine an index of the entry, then it constructs trap frame and passes control to ''OnTrap'' C function. If the trap occurred while executing user mode code the ''TrapHandler'' will call ''OnUserRet'' C function before return. 

''OnTrap'' function calls ''IDT::HandleTrap'' method if the ''idt'' object is already created. ''IDT'' will call registered handler for this trap if it exists. Anyone can register the handler for any index using ''IDT::RegisterHandler()'' method.